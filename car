'''
import pygame
import math

screen_width = 1500
screen_height = 800


class Car:
    def __init__(self):
        self.surface = pygame.image.load("car.png")
        self.surface = pygame.transform.scale(self.surface, (100, 100))
        self.rotate_surface = self.surface
        self.pos = [700, 650]
        self.angle = 0
        self.speed = 0
        self.center = [self.pos[0] + 50, self.pos[1] + 50]
        self.radars = []
        self.radars_for_draw = []
        self.is_alive = True
        self.goal = False
        self.distance = 0
        self.time_spent = 0

    def draw(self, screen):
        screen.blit(self.rotate_surface, self.pos)
        self.draw_radar(screen)

    def draw_radar(self, screen):
        for r in self.radars:
            pos, dist = r
            pygame.draw.line(screen, (0, 255, 0), self.center, pos, 1)
            pygame.draw.circle(screen, (0, 255, 0), pos, 5)

    def check_collision(self, map):
        self.is_alive = True
        for p in self.four_points:
            if map.get_at((int(p[0]), int(p[1]))) == (255, 255, 255, 255):
                self.is_alive = False
                break

    def check_radar(self, degree, map):
        len = 0
        x = int(self.center[0] + math.cos(math.radians(360 - (self.angle + degree))) * len)
        y = int(self.center[1] + math.sin(math.radians(360 - (self.angle + degree))) * len)

        while not map.get_at((x, y)) == (255, 255, 255, 255) and len < 300:
            len = len + 1
            x = int(self.center[0] + math.cos(math.radians(360 - (self.angle + degree))) * len)
            y = int(self.center[1] + math.sin(math.radians(360 - (self.angle + degree))) * len)

        dist = int(math.sqrt(math.pow(x - self.center[0], 2) + math.pow(y - self.center[1], 2)))
        self.radars.append([(x, y), dist])

    def update(self, map):
        # check speed
        self.speed = 7

        # check position
        self.rotate_surface = self.rot_center(self.surface, self.angle)
        self.pos[0] += math.cos(math.radians(360 - self.angle)) * self.speed
        if self.pos[0] < 20:
            self.pos[0] = 20
        elif self.pos[0] > screen_width - 120:
            self.pos[0] = screen_width - 120

        self.distance += self.speed
        self.time_spent += 1
        self.pos[1] += math.sin(math.radians(360 - self.angle)) * self.speed
        if self.pos[1] < 20:
            self.pos[1] = 20
        elif self.pos[1] > screen_height - 120:
            self.pos[1] = screen_height - 120

        # caculate 4 collision points
        self.center = [int(self.pos[0]) + 50, int(self.pos[1]) + 50]
        len = 40
        left_top = [self.center[0] + math.cos(math.radians(360 - (self.angle + 30))) * len,
                    self.center[1] + math.sin(math.radians(360 - (self.angle + 30))) * len]
        right_top = [self.center[0] + math.cos(math.radians(360 - (self.angle + 150))) * len,
                     self.center[1] + math.sin(math.radians(360 - (self.angle + 150))) * len]
        left_bottom = [self.center[0] + math.cos(math.radians(360 - (self.angle + 210))) * len,
                       self.center[1] + math.sin(math.radians(360 - (self.angle + 210))) * len]
        right_bottom = [self.center[0] + math.cos(math.radians(360 - (self.angle + 330))) * len,
                        self.center[1] + math.sin(math.radians(360 - (self.angle + 330))) * len]
        self.four_points = [left_top, right_top, left_bottom, right_bottom]

        self.check_collision(map)
        self.radars.clear()
        for d in range(-90, 120, 45):
            self.check_radar(d, map)

    def get_data(self):
        radars = self.radars
        ret = [0, 0, 0, 0, 0]
        for i, r in enumerate(radars):
            ret[i] = int(r[1] / 30)

        return ret

    def get_alive(self):
        return self.is_alive

    def get_reward(self):
        return self.distance / 50.0

    def rot_center(self, image, angle):
        orig_rect = image.get_rect()
        rot_image = pygame.transform.rotate(image, angle)
        rot_rect = orig_rect.copy()
        rot_rect.center = rot_image.get_rect().center
        rot_image = rot_image.subsurface(rot_rect).copy()
        return rot_image

'''
import math
import pygame
import numpy as np


class Car(pygame.sprite.Sprite):
    def __init__(self, surface):
        self.bounded_rect = surface.get_rect()

        super(Car, self).__init__()

        self._original_image = pygame.image.load('car.png')
        self.image = self._original_image
        self.rect = self.image.get_rect()

        # Set the car right in the center of the screen
        self.rect.centery = self.bounded_rect.height / 2
        self.rect.centerx = self.bounded_rect.width - (self.rect.width / 2)

    def set_car_straight(self):
        # Set the car straight by just pointing to the original image
        self.image = self._original_image

    def move(self, x, y):
        if y < 0:
            # If we move down, rotate the image a bit so it looks like it's actually steering down
            self.image = pygame.transform.rotate(self._original_image, -5)
        elif y > 0:
            # If we move up, rotate the image a bit so it looks like it's actually steering up
            self.image = pygame.transform.rotate(self._original_image, 5)
        else:
            # If we don't move up or down, we set the car straight again
            self.set_car_straight()

        # Move the car by changing the sprite positions
        self.rect.centerx = self.rect.centerx + x
        self.rect.centery = self.rect.centery + y

        # But make sure that the sprite stays within the game screen
        self.rect.clamp_ip(self.bounded_rect)


class CarGame(object):

    # How "fast" will the game go.
    SPEED = 8

    # Length of the line
    MIDDLE_LINE_LENGTH = 40

    # The length of the gap between the lines
    MIDDLE_LINE_GAP = 80

    def __init__(self, width=640, height=400):
        # Initialize the game
        pygame.init()
        pygame.display.set_caption("Python4PHP Road Game")

        # Create the screen and background for the game
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
        self.background = pygame.Surface(self.screen.get_size()).convert()

        self.font =  pygame.font.Font(None, 24)

        # Create car and add it to a "spritegroup"
        self.car = Car(self.screen)
        self.sprites = pygame.sprite.RenderPlain((self.car))

        # Initialize middle line
        self.paint_middle_line = 0 - self.MIDDLE_LINE_GAP

        # Create arrays for center and size on the whole width
        self.road_center = np.repeat(height / 2, width)
        self.road_size = np.repeat(200, width).astype(float)

        self.points = 0

        # Paint initial road (it will be a straight road since we don't update the road)
        for i in range(self.width):
            self.paint_road()

        # Create our angles for curving the road
        self.angle1 = 0
        self.angle2 = 0
        self.angle3 = 0

        # Key variables
        self.left = False
        self.right = False
        self.up = False
        self.down = False

        # Is the game running or not
        self.running = False

    def handle_events(self):
        """
        Handles PyGame events
        """
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
                elif event.key == pygame.K_LEFT:
                    self.left = True
                elif event.key == pygame.K_RIGHT:
                    self.right = True
                elif event.key == pygame.K_UP:
                    self.up = True
                elif event.key == pygame.K_DOWN:
                    self.down = True

            if event.type == pygame.KEYUP:
                if event.key == pygame.K_LEFT:
                    self.left = False
                elif event.key == pygame.K_RIGHT:
                    self.right = False
                elif event.key == pygame.K_UP:
                    self.up = False
                elif event.key == pygame.K_DOWN:
                    self.down = False

    def check_collission(self):
        for x in range(1, self.width):
            top = self.road_center[x] - (self.road_size[x] / 2) - 20
            bottom = self.road_center[x] + (self.road_size[x] / 2) + 20
            if self.car.rect.collidepoint(x, top):
                self.running = False
                return
            if self.car.rect.collidepoint(x, bottom):
                self.running = False
                return

        pass

    def run(self):
        self.running = True

        # Iterate while running
        while self.running:
            # Increase your points
            self.points += 1

            # Handle events
            self.handle_events()

            # Check if we need to move the car
            if self.left:
                self.car.move(-3, 0)
            elif self.right:
                self.car.move(+3, 0)
            elif self.up:
                self.car.move(0, -3)
            elif self.down:
                self.car.move(0, +3)
            else:
                # We're not moving, so put our car straight again
                self.car.set_car_straight()

            # call update for all our sprites (if they need it)
            self.sprites.update()

            # Update and paint the road on our background
            for i in range(self.SPEED):
                self.update_road()
                self.paint_road()

            self.update_screen()

            self.check_collission()

        pygame.quit()
        print("Game over. You've scored %s points" % self.points)

    def update_screen(self):
        # Paint background
        self.screen.blit(self.background, (0, 0))

        # Plot texts
        self.plot_text(10, 10, "Road size: {:3}".format(int(self.road_size[0])))
        self.plot_text(10, 25, "Points: {:3}".format(self.points))

        # Draw the sprites
        self.sprites.draw(self.screen)

        # Flip the buffer to the screen
        pygame.display.flip()


    def update_road(self):
        # rotate center and sizes
        self.road_center = np.roll(self.road_center, 1)
        self.road_size = np.roll(self.road_size, 1)

        # Set the new road size by decreasing a bit from the previous one
        self.road_size[0] = self.road_size[1] - 0.01

        # Update our angles with different speeds
        self.angle1 = self.angle1 + 0.1
        self.angle1 = self.angle1 % 360

        self.angle2 = self.angle2 + 0.041
        self.angle2 = self.angle2 % 360

        self.angle3 = self.angle3 - 0.152
        self.angle3 = self.angle3 % 360

        # Calculate the new road center, with the angles, this will nicely curve on the screen
        self.road_center[0] = (self.height / 2) - \
                  ((self.height / 6) * math.sin(math.radians(self.angle1))) - \
                  ((self.height / 6) * math.sin(math.radians(self.angle2))) - \
                  ((self.height / 6) * math.sin(math.radians(self.angle3)))

        # Increase middle line counter and wrap on the given length (it doesn't paint anything here)
        self.paint_middle_line = self.paint_middle_line + 1
        if self.paint_middle_line == self.MIDDLE_LINE_LENGTH:
            self.paint_middle_line = 0 - self.MIDDLE_LINE_GAP


    def paint_road(self):
        # Move whole background one pixel to the left
        self.background.scroll(1, 0)

        # Find the top and bottom of the road in pixels
        top = int(self.road_center[0] - (self.road_size[0] / 2))
        bottom = int(self.road_center[0] + (self.road_size[0] / 2))

        # Iterate the whole height of the game screen
        for i in range(self.height):
            if i > bottom:
                # Print a green pixel at the bottom
                c = (0, 200, 0)
            elif i == bottom:
                # Print the road edge
                c = (255, 255, 255)
            elif i > top:
                # Print the actual road
                c = (40, 40, 40)
            elif i == top:
                # Print an edge again
                c = (255, 255, 255)
            else:
                # Print the top green pixels
                c = (0, 200, 0)
            self.background.set_at((0, i), c)

        # Check if the middle line is positive, if so we can just paint a middle line
        if self.paint_middle_line > 0:
            c = (255, 255, 0)
            self.background.set_at((0, int(self.road_center[0]-1)), c)
            self.background.set_at((0, int(self.road_center[0])), c)
            self.background.set_at((0, int(self.road_center[0]+1)), c)


    def plot_text(self, x, y, text):
        surface = self.font.render(text, True, (0, 0, 0))
        self.screen.blit(surface, (x, y))


if __name__ == '__main__':
    CarGame(640, 480).run()
